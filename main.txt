#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <string.h>

// Fun√ß√£o para identificar o sistema operacional e incluir a biblioteca
#ifdef __linux__
	#include <unistd.h>
#elif _WIN32
	#include <windows.h>
#endif

// Fun√ß√£o clean conforme o sistema operacional
void clear() {
	#ifdef __linux__
		system("clear");
	#elif _WIN32
		system("cls");
	#else
	#endif
}

// void sleep() {
//     int i=0;

//     while (i++ < 10) {
//         #ifdef _WIN32 || _WIN64
//         //Sleep(1000); // Sleep 1 segundo
//         Sleep(1000); // Sleep 0,5 segundo
//         #elif _WIN32
//         //sleep(1); // Sleep 1 segundo
//         usleep(1000*1000);  // Sleep 0,5 segundo (500 milisegundos)
//         #else
//         #endif
//         printf(".");
//     }
// }


// cores
#define RED "\x1B[31m"
#define GRN "\x1B[32m"  
#define YEL "\x1B[33m"
#define BLU "\x1B[34m"
#define MAG "\x1B[35m"
#define CYN "\x1B[36m"
#define WHT "\x1B[37m"
#define RESET "\x1B[0m"

/* Fun√ß√µes B√°sicas Disponibilizadas */

// Gerador de n√∫meros aleat√≥rios
int randomInteger (int low, int high) {
    int k;
    double d;

    d = (double) rand () / ((double) RAND_MAX + 1);
    k = d * (high - low + 1);

    return low + k;
}

// Fun√ß√£o para gerar o mapa
void geraMapa(int mapa[10][10], int nivel) {
    int i, j, qtdO, qtdA, lin, col, infO=5, supO=15;

    switch (nivel) {
        case 2: infO=5; supO=25; break;
        case 3: infO=15; supO=35; break;
    }

    srand((unsigned int)time(NULL));

    for (i=0; i<10; i++)
        for (j=0; j<10; j++)
            mapa[i][j] = 0;

    mapa[randomInteger(0,9)][0]= 1;
    mapa[randomInteger(0,9)][9]= 2;
    qtdA = randomInteger(3,10);
    qtdO = randomInteger(infO, supO);

    while (qtdO>0) {
        lin = randomInteger(0,9);
        col = randomInteger(1,8);
        if (mapa[lin][col] == 0) {
            mapa[lin][col] = 3;
            qtdO--;
        }
    }

    while (qtdA>0) {
        lin = randomInteger(0,9);
        col = randomInteger(1,8);
        if (mapa[lin][col] == 0) {
            mapa[lin][col] = 4;
            qtdA--;
        }
    }
}

// Fun√ß√£o para atualizar o mapa
void atualizaMapa(int mapa[10][10]) {
    int i, j, upd, atualizado[10][10];
    for (i=0; i<10; i++) for (j=0; j<10; j++) atualizado[i][j]=3;

    for (i=0; i<10; i++)
        for (j=0; j<10; j++) {
            if ((mapa[i][j] == 2 || mapa[i][j] == 3 || mapa[i][j] == 4) && atualizado[i][j] == 0) {
                upd = randomInteger(1,4);
                switch (upd) {
                    case 1:
                        if ((mapa[i-1][j] == 0 || (mapa[i-1][j] == 1 && mapa[i][j] == 3)) && i>0) {
                            mapa[i-1][j] = mapa[i][j];
                            mapa[i][j] = 0;
                            atualizado[i-1][j]=1;
                        }
                        break;
                    case 2:
                        if ((mapa[i+1][j] == 0 || (mapa[i+1][j] == 1 && mapa[i][j] == 3)) && i<9) {
                            mapa[i+1][j] = mapa[i][j];
                            mapa[i][j] = 0;
                            atualizado[i+1][j]=1;
                        }
                        break;
                    case 3:
                        if ((mapa[i][j+1] == 0 || (mapa[i][j+1] == 1 && mapa[i][j] == 3)) && j<9) {
                            mapa[i][j+1] = mapa[i][j];
                            mapa[i][j] = 0;
                            atualizado[i][j+1]=1;
                        }
                        break;
                    case 4:
                        if ((mapa[i][j-1] == 0 || (mapa[i][j-1] == 1 && mapa[i][j] == 3)) && j>0) {
                            mapa[i][j-1] = mapa[i][j];
                            mapa[i][j] = 0;
                            atualizado[i][j-1]=1;
                        }
                }
            }
       }
}

// Fun√ß√£o para imprimir o mapa
void imprimeMapa(int mapa[10][10]) {
    int i, j;
    printf("\n  -------------------------------------------------------------  ");
    for (i=0; i<10; i++) {
        printf("\n  -------------------------------------------------------------  \n  ");
        for (j=0; j<10; j++) {
            if (mapa[i][j]==0) {
                printf("|  "); // verificar
                printf(MAG"%d  "RESET, mapa[i][j]);
            }
            else if (mapa[i][j]==1) {
                printf("|  "); // verificar
                printf(YEL"%d  "RESET, mapa[i][j]);
            }
            else if (mapa[i][j]==2) {
                printf("|  "); // verificar
                printf(BLU "%d  "RESET, mapa[i][j]);
            }
            else if (mapa[i][j]==3) {
                printf("|  "); // verificar
                printf(GRN "%d  "RESET, mapa[i][j]);
            }
            else {
                printf("|  "); // verificar
                printf(RED "%d  "RESET, mapa[i][j]);
            }
            
                
        }
        printf("|");
    }
    printf("\n  -------------------------------------------------------------  ");
    printf("\n  -------------------------------------------------------------  \n  ");
}

/* Fun√ß√µes Desenvolvidas */

// Fun√ß√£o cronometro
void cronometro (void) {
    int segundo = 0;
    int minuto = 0;
    int hora = 0;
    
    for (int i = 0; i < 5; --i) {
        printf("\n\n\t\t%dh : %dmin : %dseg", hora, minuto, segundo);
        sleep(1000);
        system("CLS"); 
        segundo++;
        
        if (segundo == 60) {
            segundo = 0;  
            minuto++;
        }   
        
        if (minuto == 60) {
            minuto = 0;  
            hora++;
        }  
    }
}

//Fun√ß√£o para mover personagem
void moveper (int mapa[10][10], char mover) {
    int  xAtu /*linha atual*/, yAtu /*coluna atual*/, xDes /*linha desejada*/ , yDes /*coluna desejada*/;
    
    // Fun√ß√£o para achar o personagem
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            if (mapa[i][j] == 1) {
                xAtu = i; 
                yAtu = j; 
                break;
            }
        }
    }

    switch (mover) {
        case 's':
            xDes = xAtu++;
            yDes = yAtu;
            mapa[xDes][yDes]=0;
            mapa[xAtu][yAtu]=1;
        break;
        case 'w':
            xDes = xAtu--;
            yDes = yAtu;
            mapa[xDes][yDes]=0;
            mapa[xAtu][yAtu]=1;
        break;    
        case 'a':
            xDes = xAtu;
            yDes = yAtu--;
            mapa[xDes][yDes]=0;
            mapa[xAtu][yAtu]=1;
        break;
        case 'd':
            xDes = xAtu;
            yDes = yAtu++;
            mapa[xDes][yDes]=0;
            mapa[xAtu][yAtu]=1;
        break;
        default:
            printf("  Dire√ß√£o inv√°lida!\n");
        return;
    }
}


/* MAIN */
int main () {
    setlocale(LC_ALL, "Portuguese");

    /* Tela Inicial*/

    // Abertura:  Deve conter, no m√≠nimo, o nome do jogo e o nome da equipe desenvolvedora
    printf(RED "\n\n  8b,dPPYba,  ,adPPYYba,  ,adPPYba, 88,dPYba,,adPYba,  ,adPPYYba, 8b,dPPYba\n");
    printf(RED "  88P'    \"8a a8\"     \"\" a8\"     \"\" 88P'   \"88\"    \"8a \"\"     `Y8 88P'   `\"8a\n");
    printf(RED "  88       d8 8b      8b 8b         88      88      88 ,adPPPPP88 88       88\n");
    printf(RED "  88b,   ,a8\" \"8a,   ,aa \"8a,   ,aa 88      88      88 88,    ,88 88       88\n");
    printf(RED "  88`YbbdP\"'   `\"Ybbd8\"   `\"Ybbd8\"' 88      88      88 `\"8bbdP\"Y8 88       88\n");
    printf(RED "  88\n");
    printf(RED "  88\n" RESET);
    printf(YEL "\n  By Dayana Freitas, Cau√£ Azevedo e Felipe Ribeiro\n\n" RESET);
                        

    // Codinome - Entre 3 e 15 caracteres
    int n;
    char nome[30];
    printf("\n  Bem vindo ao POCMAN, antes de embarcar nessa aventura, insira seu codinome: ");
    do {
        n = 0;
        setbuf(stdin, NULL);
        scanf("%[^\n]s", nome);

        if (strlen(nome) < 3 || strlen(nome) > 15) {
            n = 1;
            if (strlen(nome) < 3 ) {
                printf("\n  Nome muito pequeno, insira um nome com 3 ou mais caracteres: ");
            }
            else {
                printf("\n  Nome muito grande, insira um nome com 15 ou menos caracteres: ");
            }
        }
    } while (n == 1);
    printf("\n");

    /* Tela de Instru√ß√µes (J1)

        Cada grupo deve formular um conjunto de instru√ß√µes de como jogar. Apresente-as na tela de
        maneira l√∫dica (considerando a hist√≥ria/narrativa) e clara.
        Logo ap√≥s as instru√ß√µes, o sistema deve dar duas op√ß√µes:
        1. Nova partida
        2. Sair do jogo

    */
   printf("  Em fliperamas muito distantes, existia um ser chamado Pocman que estava cansado de ser apenas o primo distante e queria ganhar reconhecimento\n");
   printf("  Para demonstrar seu valor, decidiu ir atr√°s da √∫nica coisa que sei primo nunca conseguiu alcan√ßar verdadeiramente, o fim do jogo\n");
   printf("  Voc√™ deve ajud√°-lo a alcan√ßar o fim e demonstrar de uma vez por todas que o verdadeiro caminho n√£o se abre para aqueles que comem comem, e sim para os que lutam\n");
   printf("  Mas tome cuidado, o caminho para a gl√≥ria √© cheio de recompensas e armadilhas para impedi-lo, seja prudente e boa sorte em sua jornada\n");

/* Nova partida (J2)

    Agora a partida do seu jogo iniciar√°. A primeira a√ß√£o √© mostrar na tela o mapa, que deve ser
    uma matriz 10x10.
    O mapa inicial deve conter:
        1. Posi√ß√£o atual do avatar;
        2. Posi√ß√£o do destino (ou objetivo);
        3. Indica√ß√£o de √°reas com obst√°culos a serem evitados;
        4. Indica√ß√£o de √°reas 0com b√¥nus.
    Use a fun√ß√£o geraMapa(int mapa[10][10], int nivel), dispon√≠vel no arquivo
    mapa.c no Moodle. Esta fun√ß√£o gera todos os elementos que devem estar no mapa inicial.
    Cada vez que a fun√ß√£o √© chamada ela gera um mapa diferente. O segundo par√¢metro (int nivel)
    √© usado para definir o n√≠vel de dificuldade da partida. Os valores poss√≠veis s√£o 1, 2 ou 3, sendo
    f√°cil, intermedi√°rio e dif√≠cil, respectivamente. Voc√™ pode escolher se vai perguntar √† jogadora
    qual o n√≠vel de dificuldade ela deseja ou se usar√° sempre um n√≠vel fixo em seu jogo. A fun√ß√£o
    preenche a matriz mapa da seguinte maneira:
    ÔÇ∑ Valor 0: posi√ß√£o por onde o avatar pode passar;
    ÔÇ∑ Valor 1: posi√ß√£o atual do avatar;
    ÔÇ∑ Valor 2: posi√ß√£o do destino (objetivo que deve ser alcan√ßado para concluir a miss√£o);
    ÔÇ∑ Valor 3: posi√ß√£o que contem um obst√°culo (evitar);
    ÔÇ∑ Valor 4: posi√ß√£o de um b√¥nus (coletar).
    Sejam criativos na apresenta√ß√£o do mapa de modo que fique simples de entend√™-lo.
    Logo abaixo do mapa voc√™ deve exibir o menu do jogo (J3).

*/
    //cronometro();
    // Impress√£o do mapa
    int mapa[10][10];
    char mover;

    geraMapa(mapa, 3);
    imprimeMapa(mapa);

    do {
        setbuf(stdin, NULL);
        printf("\n  escolha uma dire√ß√£o para ir: \n\n  ");
        scanf("%c",&mover);
        moveper(mapa,mover);
        atualizaMapa(mapa);
        //system("clear");     
        imprimeMapa(mapa);   
    } while (mover);

/* Menu do Jogo (J3)

    O menu do jogo deve trazer, pelo menos, as seguintes op√ß√µes de opera√ß√£o:
    1. Movimentar o avatar
    2. Nova partida
    3. Sair do jogo

*/

/* Movimentar o avatar (J4)

    Quando esta op√ß√£o for selecionada o jogo deve orientar a jogadora a usar as setas direcionais ou
    WSAD ([W] - cima, [S] - baixo, [A] - esquerda e [D] ‚Äì direita) para movimentar o avatar.
    A cada tecla direcional pressionada voc√™ deve alterar a posi√ß√£o do avatar no mapa,
    considerando:
    1. [REQ_BONUS];
    2. [REQ_OBSTACULO];
    3. [REQ_VITORIA];
    4. [REQ_LIMITE];
    5. Atualizar a apresentar a pontua√ß√£o atual da partida, conforme [REQ_PONTUACAO].
    Se qualquer outra tecla for pressionada, ela deve ser ignorada pelo jogo. Mas n√£o precisa
    mostrar nenhuma mensagem de erro.
    Depois de movimentar o avatar e verificar o que ocorreu, voc√™ deve atualizar o mapa. Para isso:
    1. Atualize a posi√ß√£o do avatar na matriz mapa;
    2. Imprima novamente o mapa na tela;
    3. Aguarde 1 segundo (ver fun√ß√£o sleep da biblioteca time.h);
    4. Chame a fun√ß√£o atualizaMapa(int mapa[10][10]), dispon√≠vel no arquivo
    mapa.c. Ela realiza a atualiza√ß√£o do mapa, trazendo as novas posi√ß√µes dos obst√°culos,
    b√¥nus e do destino (objetivo);
    5. Reaizar [REQ_ATUALIZACAO];
    6. Imprima novamente o mapa atualizado na tela.
    Ao concluir a partida:
    1. Se alcan√ßou o destino (objetivo), ent√£o apresentar:
    a. Uma mensagem de finaliza√ß√£o da partida (n√£o se esque√ßa de usar o codinome
    da jogadora);
    b. A quantidade de pontos obtidos;
    c. Voltar para (J1).
    2. Se a miss√£o fracassou, ent√£o apresentar:
    a. Informar o motivo: obst√°culo [REQ_OBSTACULO] ou saiu do mapa
    [REQ_LIMITE];
    b. Voltar para (J1).
    3. Em qualquer dos casos, se a pontua√ß√£o for maior que 0 (zero) deve verificar se a
    pontua√ß√£o vai para o ranking [REQ_RANKING]:
    a. Abrir o arquivo bin√°rio rank.dat e obter os dados das tr√™s maiores
    pontua√ß√µes contidas l√°. Esse arquivo deve armazenar as tr√™s maiores
    pontua√ß√µes e os respectivos codinomes de quem as obteve;
    b. Se a pontua√ß√£o da partida atual for maior que alguma das pontua√ß√µes
    anteriores, ent√£o atualizar devidamente o ranking;
    c. Imprimir na tela o ranking atualizado.

*/

/* Nova partida (J5)

    Quando esta op√ß√£o for selecionada, voc√™ deve pedir a confirma√ß√£o da jogadora e ent√£o deve
    voltar para o (J2).

*/

/* Sair do jogo (J6)

Ao selecionar esta op√ß√£o, o jogo deve pedir uma confirma√ß√£o da jogadora antes de encerrar a
execu√ß√£o do programa. Se confirmar, exibir uma mensagem de despedida e encerra o jogo.

*/

    // Fun√ß√£o para imprimir mapa
    /////////////////////////////////////////////////////////////////////////////////////
    // int mapa[10][10], at;
    // geraMapa(mapa, 3);
    // imprimeMapa(mapa);

    // // Atualiza√ß√£o do mapa
    // do {
    //     printf("\nAtualizar mapa? Resposta (1-Sim, 0-N√£o) üëª: üçí üò∂ üçÖ üçé üçá  ü´†");
    //     scanf("%d", &at);

    //     if (at) { atualizaMapa(mapa); imprimeMapa(mapa); }

    // } while (at);
    return 0;
}